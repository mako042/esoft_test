# Задачи

## 1. Разработать конфигурацию nginx способную с помощью определения типа устройства отдавать разные html странички (просто можно взять банальный HELLO, YOU FROM “Тип устройства”). Под типом устройства понимается Десктоп, Планшет, Смартфон.
Как реализовано:  
1. Сделана мапа $http_user_agent $type
2. Для каждого юзерагента определены типы устройств с помощью регулярных выражений. Например: ~.(Windows|x86|x64|U)   pc
3. Создано 3 файла с разными именами. При посещении страницы, после проверки юзерагента и присвоении переменной $type значения, начинается поиск файла с именем /$type.html с помощью try_files. Если файл не найден, выводится страница для десктопа. 

## 2. Написать скрипт на go с возможностью проверять доступность сайта например localhost. Необходимо хранить значения доступности в виде json файла построчно. А также последнее удачное или неудачное значение, с помощью которого можно ставить метки/отправлять сообщения о даунтайме или аптайме сайта.
Как реализовано: 
1. Созданы две структуры для хранения текущей информации и последнего статуса, отличающегося от текущего. 
2. С помощью http.Get проверяется доступность сайта, статус код, с периодичностью раз в х секунд. Значение можно изменить. 
3. Данные записываются в json, которое имеет имя формата logs_дата_время.json. 
4. В случае, если изменяется доступность сайта, выводится оповещение в консоль формата:
```
=== NOTIFICATION ===
Время: 18_Sep_2025_21-25-26
Информация: Изменение статуса сайта. Текущее состояние: UP 
Прошло времени с последнего изменения статуса: 10с
URL: http://example.com/
================================
```
В прикреплённых логах можно посмотреть пример изменения доступности (во время работы скрипта физически ребуталась машина для эмуляции отказа работы сайта) 

## 3. Написать демон для systemd, который будет поддерживать работу приложения “watch -n5 ‘du -s /var/log/’” записывать результаты в лог и восстанавливаться после падения.
Как реализовано:
1. Создан файл watch_du.service, STDOUT перенаправляется в /var/log/watchlogs.txt, STDERR в /dev/null.
2. Задана перезагрузка в случае on-success (так как watch при перезагрузке завершает работу с кодом 0, ему не подходит вариант перезапуска on-failure). Так же, задана переменная окружения TERM=linux.
3. Сервис активирован командой systemctl enable. Пример вывода можно посмотреть в прикреплённом файле watchlogs.txt.
